# frozen_string_literal: true

require "delegate"

module SurflinerSchema
  ##
  # A class, section, grouping, etc enumerable which delegates back to the
  # original description but allows enumeration of its contents.
  #
  # Instances of this class are automatically generated by
  # +SurflinerSchema::Loader#class_division_for+; they shouldn’t be modified
  # directly.
  class Division < SimpleDelegator
    include Enumerable

    attr_accessor :kind
    attr_accessor :reader

    ##
    # Initializes a new +SurflinerSchema::Division+ from the corresponding
    # description of the provided name and kind in the provided reader.
    def initialize(name:, kind:, reader:)
      @kind = kind
      @reader = reader
      case kind
      when :class
        super(reader.resource_classes[name])
      when :section
        super(reader.sections[name])
      when :grouping
        super(reader.groupings[name])
      else
        raise ArgumentError.new("Kind not recognized.")
      end
    end

    ##
    # Yields the groupings and ungrouped properties in this division, in order.
    def each
      items.each do |item|
        yield item
      end
    end

    ##
    # Returns an array of properties contained in this division or any
    # subdivisions.
    def properties
      result = []
      each do |item|
        if item.respond_to?(:properties)
          result += item.properties
        else
          result << item
        end
      end
      result
    end

    ##
    # Adds the provided property.
    #
    # If the provided property has already been added, this is a no·op.
    def <<(property)
      acceptable = false
      subdivision = nil
      case kind
      when :class
        # This is a class division; it may have section or grouping
        # subdivisions.
        acceptable = property.available_on.include?(name)
        if !property.section.nil?
          subdivision = {name: property.section, kind: :section}
        elsif !property.grouping.nil?
          subdivision = {name: property.grouping, kind: :grouping}
        end
      when :section
        # This is a section division; it may have grouping subdivisions.
        acceptable = property.section == name
        if !property.grouping.nil?
          subdivision = {name: property.grouping, kind: :grouping}
        end
      when :grouping
        # This is a grouping division; no subdivisions are supported.
        acceptable = property.grouping == name
      end
      raise ArgumentError.new("Invalid property.") unless acceptable
      if subdivision.nil?
        # The property does not have an associated section/grouping within this
        # class/section.
        if !itemset.include?(property)
          itemset << property
          items << property
        end
      elsif subdivisions[subdivision[:kind]].include?(subdivision[:name])
        # The property has an associated subdivision, which has already been
        # added.
        subdivisions[subdivision[:kind]][subdivision[:name]] << property
      else
        # The property has an associted subdivision, but none has been added
        # yet.
        div = SurflinerSchema::Division.new(**subdivision, reader: reader)
        subdivisions[subdivision[:kind]][subdivision[:name]] = div
        div << property
        items << div
      end
    end

    private

    ##
    # The ordered divisions and top‐level properties in this division.
    def items
      @items ||= []
    end

    ##
    # A set of items which have already been added to this division.
    #
    # This doesn’t include items in subdivisions (which is recorded in the
    # subdivisions themselves).
    def itemset
      @itemset ||= Set.new
    end

    ##
    # The subdivisions which have already been added to this division, by kind
    # and name.
    def subdivisions
      @subdivisions ||=
        case kind
        when :class
          {section: {}, grouping: {}}
        when :section
          {grouping: {}}
        else
          {}
        end
    end
  end
end
