stages:
  - maintanence
  - build
  - lint
  - test
  - integration
  - review
  - staging
  - production
  - cleanup
  - failure_notification

include:
  - local: ci/base.yml
  - local: ci/lark.yml
  - local: ci/shoreline.yml
  - local: ci/starlight.yml

# Build with Kaniko. When building on `master`, tag a new stable image.
.build_helpers: &build_helpers |
  set -x
  build_image_for() {
    if test $# -ne 2 ; then
        echo "You must specify a project path to a Dockerfile and an image name. example: build_image_for 'starlight' 'starlight_web'"
      exit 1
    fi
    project=$1
    image_name=$2
    destination="--destination $CI_REGISTRY_IMAGE/$image_name:$CI_COMMIT_SHA"
    if [ "$CI_COMMIT_BRANCH" = "master" ]; then
      destination="$destination --destination $CI_REGISTRY_IMAGE/$image_name:stable"
    fi
    /kaniko/executor --context "$CI_PROJECT_DIR"/$project --cache=true --dockerfile "$CI_PROJECT_DIR"/"$project"/Dockerfile $destination
  }


# Use Kaniko for building container images
.kaniko-build:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug-v0.22.0
    entrypoint: [""]
  before_script:
    - *build_helpers
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json


# Surfliner-specific helm chart setup to include additional helm repos
.deploy_helpers: &deploy_helpers |
  [[ "$TRACE" ]] && set -x
  function build_chart_dependencies() {
    helm init --client-only

    helm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com/
    helm repo add bitnami https://charts.bitnami.com/bitnami

    helm dependency update chart/
    helm dependency build chart/
  }

# Gitlab image used for deployment
# see: https://gitlab.com/gitlab-org/gitlab-ce/blob/master/lib/gitlab/ci/templates/Jobs/Deploy.gitlab-ci.yml
.auto-deploy:
  image: "registry.gitlab.com/gitlab-org/cluster-integration/auto-deploy-image:v0.1.0"
  except:
    variables:
      - $NO_DEPLOY == "true"
  before_script:
    - *deploy_helpers

# Default only -> refs settings for all jobs
# see: https://docs.gitlab.com/ee/ci/yaml/#onlyrefsexceptrefs
.only-refs-default:
  only:
    refs:
      - master
      - merge_requests
      - tags

  # Helm 3 deployment helper functions
.helm3_deploy_helpers: &helm3_deploy_helpers |
  function deploy() {
    setup_helm_dependencies

    if helm ls --namespace="$KUBE_NAMESPACE" -q | grep -q "$HELM_RELEASE_NAME"; then
      echo "Deploying new release: $HELM_RELEASE_NAME..."
    else
      first_release="yes"
      echo "Deploying initial release: $HELM_RELEASE_NAME..."
    fi
    helm upgrade \
        --install \
        --atomic \
        --set image.repository="$DEPLOY_IMAGE" \
        --set image.tag="$DEPLOY_TAG" \
        $HELM_UPGRADE_EXTRA_ARGS \
        --namespace="$KUBE_NAMESPACE" \
        "$HELM_RELEASE_NAME" \
        chart/
  }

  # Setup helm repositories
  function setup_helm_dependencies(){
    echo "Setting up Helm repositories for chart dependencies.."
    # dynamically add helm repositories based on helm dependency listing
    repos=$(helm dep list chart/ | grep http | cut -f3 | uniq)
    if test -z "$repos"; then
      echo "This Helm chart has no dependencies.."
      return
    fi
    index=0
    for repo in $repos
    do
      helm repo add "repo-$index" "$repo" --no-update
      index=${index+1}
    done
    download_chart_dependencies
  }

  # Install chart dependencies
  function download_chart_dependencies(){
    echo "Downloading Helm chart dependencies.."
    # update charts/ based on the contents of Chart.yaml
    helm dependency update chart/
    # rebuild the charts/ directory based on the Chart.lock file
    helm dependency build chart/
  }

  function delete() {
    echo "Deleting release: $HELM_RELEASE_NAME..."
    helm delete --namespace "$KUBE_NAMESPACE" "$HELM_RELEASE_NAME"
  }

  # note: should not be used in production
  function delete_stateful_set_pvcs(){
    echo "Deleting any StatefulSet Persistent Volume Claims..."
    # postgresql and zookeeper
    kubectl delete pvc -l release="$HELM_RELEASE_NAME" --namespace="$KUBE_NAMESPACE"
    # solr
    kubectl delete pvc -l "app.kubernetes.io/instance=$HELM_RELEASE_NAME" --namespace="$KUBE_NAMESPACE"
  }

  function rollback() {
    echo "Rolling back to previous release of: $HELM_RELEASE_NAME..."
    helm rollback --wait --namespace "$KUBE_NAMESPACE" "$HELM_RELEASE_NAME"
  }

  function ensure_namespace() {
    kubectl get namespace "$KUBE_NAMESPACE" || kubectl create namespace "$KUBE_NAMESPACE"
  }

  # A GitLab-integrated Kubernetes cluster should already have a KUBECONFIG created
  # Otherwise, we assume the KUBECONFIG is setup as a base64-encoded environment variable
  function setup_kube_config(){
    if [ -z "${KUBECONFIG}" ]; then
      echo "A GitLab KUBECONFIG file was not detected, using KUBE_ROLE_CONFIG env var.."
      mkdir -p /etc/deploy
      export KUBECONFIG=/etc/deploy/config
      echo ${KUBE_ROLE_CONFIG} | base64 -d > $KUBECONFIG
    fi
  }

# Helm3-based image for tiller-less deploys
.helm3-deploy:
  image: "dtzar/helm-kubectl:3.1.2"
  stage: deploy
  before_script:
    - *helm3_deploy_helpers
    - setup_kube_config
    - ensure_namespace
